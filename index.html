<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <style>
    :root {
      --neon-blue: #0ff;
      --glitch-duration: 1.2s;
    }

    @keyframes glitch {
      0% { text-shadow: 0.05em 0 0 rgba(255,0,0,.8); }
      25% { transform: skew(0.8deg); }
      50% { text-shadow: -0.05em -0.025em 0 rgba(0,255,0,.8); }
      75% { transform: skew(-0.6deg); }
      100% { text-shadow: 0.025em 0.05em 0 rgba(0,0,255,.8); }
    }

    .cipher-text {
      font-family: 'Courier New', monospace;
      color: var(--neon-blue);
      background: #000;
      padding: 1rem;
      border: 1px dashed #4d4d4d;
      animation: glitch var(--glitch-duration) infinite;
    }

    .quantum-key:hover {
      cursor: pointer;
      filter: hue-rotate(90deg);
    }

    .hidden-layer {
      display: none;
      position: absolute;
      background: #111;
      padding: 1rem;
      border: 2px solid var(--neon-blue);
    }

    .key-block:hover + .hidden-layer {
      display: block;
    }
  </style>
</head>
<body style="background: #000; color: #fff; max-width: 800px; margin: 0 auto;">
  <div class="cipher-text">
    01010011 01000101 01000011 01001111 01001110 01000100...
  </div>

 <!-- 在隐藏线索部分修正坐标 -->
<div class="hidden-layer" id="waveform-clue">
  波形频率: 17.76kHz<br>
  对应坐标: 35.662575°N, 139.486114°E
</div>

<!-- 地理谜题数据层修正 -->
<div hidden 
     data-venue="tokyo_racecourse"
     data-lat="35.6625751918206" 
     data-lng="139.48611428515687"
     style="display:none;">
  <!-- 实际赛事数据接口示例 -->
  <script>
    fetch(`/api/race?lat=${this.dataset.lat}&lng=${this.dataset.lng}`)
      .then(res => res.json())
      .then(data => console.log('赛道状态:', data.track_condition))
  </script>
</div>

<!-- 动态密钥生成逻辑绑定 -->
<script>
  // 基于真实坐标的密钥算法示例
  function generateDynamicKey() {
    const lat = 35.6625751918206;
    const lng = 139.48611428515687;
    const salt = Math.floor((lat * 1000 % 256) ^ (lng * 1000 % 256));
    return salt.toString(16).padStart(4, '0').toUpperCase(); // 示例输出: "BE5F"
  }

  // 在验证时加入坐标验证
  function validateKey() {
    const input = document.getElementById('keyInput').value;
    const expected = generateDynamicKey();
    // ...后续验证逻辑...
  }
</script>
  <div class="security-alert">
    <h2>〘特雷森学园安全委员会通知〙</h2>
    <p>检测到<redacted>██级协议突破事件</redacted></p>
  </div>

  <hr style="border: 1px dashed #444;">

  <div class="phase-info">
    <h3>◈ 相位迁移公告 ◈</h3>
    <ul>
      <li>量子纠缠效验系统 <span class="countdown" data-end="2025-03-01"></span></li>
      <li>反制协议β：<span id="error-counter">0/3</span> 次错误</li>
    </ul>
  </div>

  <div class="key-interface" style="position: relative;">
    <div class="key-block">1F23 8A9C ████ QWE5</div>
    <div class="hidden-layer">
      <form onsubmit="validateKey(event)">
        <input type="text" placeholder="输入恢复密钥" 
               pattern="[0-9A-F]{4}" maxlength="4"
               style="background: #222; color: var(--neon-blue);">
        <button type="submit">提交</button>
      </form>
    </div>
  </div>

  <script>
    function revealFrequency() {
      const coord = document.getElementById('waveform-clue');
      coord.style.display = coord.style.display === 'block' ? 'none' : 'block';
    }

    function validateKey(e) {
      e.preventDefault();
      const input = e.target.querySelector('input');
      if (/^[A-F0-9]{4}$/.test(input.value)) {
        alert('量子签名验证中...');
        // 实际应调用API校验
      } else {
        const counter = document.getElementById('error-counter');
        counter.textContent = `${Math.min(parseInt(counter.textContent)+1, 3)}/3`;
      }
    }

    // 倒计时自动更新
    setInterval(() => {
      const end = new Date('2025-03-01');
      const diff = end - new Date();
      document.querySelector('.countdown').textContent = 
        `${Math.floor(diff/86400000)}天${Math.floor((diff%86400000)/3600000)}时`;
    }, 1000);
  </script>
</body>
</html>
